// "qtc_node.cpp"
// This program subscribes to the position of two agents in morse (global position) to build the QTC representations.
#include <ros/ros.h>
#include <geometry_msgs/PoseStamped.h>
#include <iostream>
#include <cmath>
using namespace std;

double const PI = 3.14159265358979323846;

bool PreviousDataAvailable = false;
bool Pt1_Received = false, Pt2_Received = false; //Flags of upgraded data
geometry_msgs::Pose Pt1_Pose0, Pt2_Pose0; // Previous poses
geometry_msgs::Pose Pt1_Pose1, Pt2_Pose1; // Current  poses

// QTC
string qtc_state0 = ""; // Previous qtc state
string qtc_state1 = ""; // Current  qtc state
bool PreviousQTCAvailable = false;

void BuildQTC(string *qtc_state,  geometry_msgs::Point Pl0, geometry_msgs::Point Pl1, geometry_msgs::Point Pk0, geometry_msgs::Point Pk1 );
bool PoseCmp( geometry_msgs::Point p1, geometry_msgs::Point p2 ); //True if equal
double SubAngles( double A, double B ); // A - B

void Pt1_Callback ( const geometry_msgs::PoseStamped::ConstPtr& msg ){
  Pt1_Received = true;
  Pt1_Pose1 = msg->pose;
  cout << "AGENT_1" << endl;
}
void Pt2_Callback ( const geometry_msgs::PoseStamped::ConstPtr& msg ){
  Pt2_Received = true;
  Pt2_Pose1 = msg->pose;
  cout << "AGENT_2" << endl;
}

int main( int argc, char **argv ){

  ros::init(argc, argv, "qtc_node");

  ros::NodeHandle n;
  ros::Subscriber node_sub1 = n.subscribe( "/lenka/lpose", 2, Pt1_Callback );
  ros::Subscriber node_sub2 = n.subscribe( "/ferdi/fpose", 2, Pt2_Callback );

  while( ros::ok() ){
    if( Pt1_Received && Pt2_Received ){
      Pt1_Received = false; //|-> Wait for updated data
      Pt2_Received = false; //|
      if( PreviousDataAvailable ){ // We have current and previous states to compare movement, try to build QTC.
	cout << "Sensor Data Available" << endl;
	//BuildQTC();
      }

      if( !PreviousQTCAvailable ){ // No previous state
	cout << "Previous QTC Available" << endl;
	cout << "(" << qtc_state1 << ")" << endl;
      }
      else if( qtc_state0 != qtc_state1 ) // Previous state and change ocurred
	cout << "(" << qtc_state1 << ")" << endl;
      else; // No change

      cout << "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%" << endl;

      PreviousQTCAvailable = true;
      qtc_state0 = qtc_state1; // Update QTC state

      Pt1_Pose0 = Pt1_Pose1; //|-> Upgrade states
      Pt2_Pose0 = Pt2_Pose1; //|
      PreviousDataAvailable = true;
    }
    ros::spinOnce();
  }
  return 0;
}

void BuildQTC(string *qtc_state,  geometry_msgs::Point Pl0, geometry_msgs::Point Pl1, geometry_msgs::Point Pk0, geometry_msgs::Point Pk1 ){
  // bool Pl_Moving = !PoseCmp( Pl0, Pl1 );
  // bool Pk_Moving = !PoseCmp( Pk0, Pk1 );
  // bool Plk_Equal = PoseCmp( Pl0, Pk0 ) || PoseCmp( Pl1, Pk1 );
  // if( Plk_Equal ){
  //   qtc_state = string( "ERROR" );
  // }
  // else{
  //   // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  //   // 1) Obtain the linking line between the two points:
  //   double m_LK = atan2( Pl1.y - Pk1.y, Pl1.x - Pk1.x ); // angle of the connecting line
  //   //double m_KL = atan2( Pk1.y - Pl1.y, Pk1.x - Pl1.x ); // angle of the connecting line
    
  //   // 2) Obtain movement direction of Pl = L
  //   if( Pl_Moving )
  //     double  m_L = atan2( Pl1.y - Pl0.y, Pl1.x - Pl0.x ); 
    
  //   // 3) Obtain movement direction of Pk = K
  //   if( Pk_Moving )
  //     double  m_K = atan2( Pk1.y - Pk0.y, Pk1.x - Pk0.x ); 
    
  //   // BUILDING QTC
    
  //   // a) Movement of K with respect to L
  //   if( fabs( SubAngles( m_L, m_LK ) ) < PI ) //Goes away
  //     qtc_state += "-";
  //   else if(  )
      
  //   // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
  // }
}


double SubAngles( double A, double B ){ // A - B
  double answer = A - B;
  while( fabs( answer ) > PI ){
    if( answer > 0 )
      answer -= 2*PI;
    else
      answer += 2*PI;
  }
  return answer;
}


bool PoseCmp( geometry_msgs::Point p1, geometry_msgs::Point p2 ){ //True if equal
  bool answer = true;
  answer &= ( p1.x == p2.x );
  answer &= ( p1.y == p2.y );
  answer &= ( p1.z == p2.z );
  return answer; 
}



